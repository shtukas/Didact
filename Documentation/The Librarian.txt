
### The Librarian 

The librarian manipulate JSON objects which encode the stuctures used both by Catalyst and Nyx.

To be Librarian compatible, an object must have the following keys:
    - "uuid" 
    - "clique"
    - "mikuType"

and we also need (see below)

    - lxGenealogyAncestors

We can retrieve objects individually by "uuid" or collectively by "mikuType"s.

objects.sqlite3
CREATE TABLE _objects_ (_uuid_ text primary key, _clique_ text, _mikuType_ text, _object_ text);

### Objects of the Nyx's network

Objects of the Nyx Network, so essentially NxDataNode must have: 
    - "uuid" 
    - "clique"
    - "mikuType"
    - "unixtime"
    - "datetime"

The unixtime (integer, but also float) should represent the time the object was created, and the datetime (DateTime Iso 8601 UTC Zulu) should represent the logical position of the object on the Nyx timeline.

### The Librarian CRDT

To maintain consistency and resolve conflicts, each librarian object has one further attribute: `lxGenealogyAncestors`, an array of strings

Given two objects of the same uuid, we says that object B is a decendent of A, alternatively that object A is an ancestor of B, if A's lxGenealogyAncestors is a subset of B's lxGenealogyAncestors.

When an object is submitted to the Librarian as part of event processing, then the current version of that object can be replaced by the event version if the event version is a decendant of the existing version.

Newly created objects are created with an empty lxGenealogyAncestors.

### The Librarian CRDT is details

- When an object is commited to the librarian, then:

    Rule 1. If it didn't have a lxGenealogyAncestors pair, then we assume that the object has just been created by whichever subsistem it comes from and the Librarian gives it an empty lxGenealogyAncestors.

    Rule 2. if it did have a lxGenealogyAncestors we add a random string to it.

    Rule 3. The object with updated attribute is then sent to various event publishers.

- When an object is given to the Librarian as part of even processing then:

    Rule 4. If there were no existing object with this uuid in the object store, then we add the new object to the object store.

    Rule 5. Rule 4, is overriden by the special processing of object types that are not meant to be stored but carry instructions, for instance, the NxDeleted type.

    Rule 6. If there is an existing object which is an ancestor of the event, then the event is replacing the existing object.

    Rule 7. If there is an existing object that is not an ancestor of the new one, then the new object is ignored. Note that in this case we also perform the additional operation of sending the existing one as an event to Stargate Central. (This is to push Central to perform a reconciliation if this had not already done.)

    Rule 8. There can be a case where the two objects are not compatible (none is the ancestror of the other), but still carry the same information, then we extend the two objects to be descendent of each other and store/publish one of them.

