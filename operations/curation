#!/usr/bin/ruby

# encoding: UTF-8

require_relative "../Libs/loader.rb"

# ========================================================================================
# Landing on items with large Dxf1 files (biggest number of related comes first)
# We want to turn them into Dx8Units and free DxF1 transfer between laptops

$cache = {}

def size(filepath)
    return $cache[filepath] if $cache[filepath]
    puts "looking  : #{filepath}"
    size1 = XCache::getOrNull("a99a66c3-3a38-4dbd-a3ae-c1e6ecd506db:#{filepath}")
    if size1 then
        size1 = size1.to_i
        $cache[filepath] = size1
        return size1.to_i 
    end
    puts "computing: #{filepath}"
    size1 = File.size(filepath)
    XCache::set("a99a66c3-3a38-4dbd-a3ae-c1e6ecd506db:#{filepath}", size1)
    $cache[filepath] = size1
    size1
end

$cache2 = {}

def decideItem(fp)
    return $cache2[fp].clone if $cache2[fp]
    item = DxF1::getProtoItemAtFilepathOrNull(fp)
    $cache2[fp] = item.clone
    item
end

loop {
    filepath = DxF1::databankRepositoryDxF1sFilepathEnumerator()
                    .reduce(nil){|filepathBig, fp|
                        item = decideItem(fp)
                        if item and Iam::isNyxNetworkItem(item) then
                            if size(filepathBig) > size(fp) then
                                filepathBig
                            else
                                fp
                            end
                        else
                            filepathBig
                        end
                    }
    puts "filepath: #{filepath}"
    item = DxF1::getProtoItemAtFilepathOrNull(filepath)
    raise "item is null" if item.nil?
    PolyPrograms::itemLanding(item)
}

exit

# ========================================================================================
# Landing on items with related (biggest number of related comes first)

$cache = {}

def size(uuid)
    return $cache[uuid] if $cache[uuid]
    puts "looking  : #{uuid}"
    count = XCache::getOrNull("a99a66c3-3a38-4dbd-a3ae-c1e6ecd506db:#{uuid}")
    if count then
        count = count.to_i
        $cache[uuid] = count
        return count.to_i 
    end
    puts "computing: #{uuid}"
    count = NetworkLinks::linkeduuids(uuid).count
    XCache::set("a99a66c3-3a38-4dbd-a3ae-c1e6ecd506db:#{uuid}", count)
    $cache[uuid] = count
    count
end

loop {
    objectuuid = TheIndex::objectuuids()
                    .reduce(nil){|objectuuid, uuid|
                        if size(objectuuid) > size(uuid) then
                            objectuuid
                        else
                            uuid
                        end
                    }
    item = TheIndex::getItemOrNull(objectuuid)
    raise "item is null" if item.nil?
    count = NetworkLinks::linkedEntities(item["uuid"]).count
    XCache::set("a99a66c3-3a38-4dbd-a3ae-c1e6ecd506db:#{item["uuid"]}", count)
    $cache[item["uuid"]] = count
    next if count == 0
    PolyPrograms::itemLanding(item)
    count = NetworkLinks::linkedEntities(item["uuid"]).count
    XCache::set("a99a66c3-3a38-4dbd-a3ae-c1e6ecd506db:#{item["uuid"]}", count)
    $cache[item["uuid"]] = count
}

exit

objectuuid = "efb38585-43fb-46dc-bdbb-1065fe30743e"
item = TheIndex::getItemOrNull(objectuuid)
relateduuids = NetworkLinks::linkeduuids(objectuuid) - ["d14d5d37-8c49-470b-b927-af7a9fb0a8f2"]
relateduuids.each{|uuid|
    NetworkArrows::link(objectuuid, uuid)
    NetworkLinks::unlink(objectuuid, uuid)
}

exit

objectuuid = "286a64a4-c9d2-49f6-8e7f-7edacea10ec6"
item = TheIndex::getItemOrNull(objectuuid)
relateduuids = NetworkLinks::linkeduuids(objectuuid) - []
relateduuids.each{|uuid|
    puts "recasting: #{uuid}"
    NetworkArrows::link(objectuuid, uuid)
    NetworkLinks::unlink(objectuuid, uuid)
}
exit